{"ast":null,"code":"'use strict';\n/* eslint-disable */\n\nvar utils = require('./utils/index.js');\n\nvar uint256Coder = utils.uint256Coder;\nvar coderBoolean = utils.coderBoolean;\nvar coderFixedBytes = utils.coderFixedBytes;\nvar coderAddress = utils.coderAddress;\nvar coderDynamicBytes = utils.coderDynamicBytes;\nvar coderString = utils.coderString;\nvar coderArray = utils.coderArray;\nvar paramTypePart = utils.paramTypePart;\nvar getParamCoder = utils.getParamCoder;\n\nfunction Result() {}\n\nfunction encodeParams(types, values) {\n  if (types.length !== values.length) {\n    throw new Error('[ethjs-abi] while encoding params, types/values mismatch, Your contract requires ' + types.length + ' types (arguments), and you passed in ' + values.length);\n  }\n\n  var parts = [];\n  types.forEach(function (type, index) {\n    var coder = getParamCoder(type);\n    parts.push({\n      dynamic: coder.dynamic,\n      value: coder.encode(values[index])\n    });\n  });\n\n  function alignSize(size) {\n    return parseInt(32 * Math.ceil(size / 32));\n  }\n\n  var staticSize = 0,\n      dynamicSize = 0;\n  parts.forEach(function (part) {\n    if (part.dynamic) {\n      staticSize += 32;\n      dynamicSize += alignSize(part.value.length);\n    } else {\n      staticSize += alignSize(part.value.length);\n    }\n  });\n  var offset = 0,\n      dynamicOffset = staticSize;\n  var data = new Buffer(staticSize + dynamicSize);\n  parts.forEach(function (part, index) {\n    if (part.dynamic) {\n      uint256Coder.encode(dynamicOffset).copy(data, offset);\n      offset += 32;\n      part.value.copy(data, dynamicOffset);\n      dynamicOffset += alignSize(part.value.length);\n    } else {\n      part.value.copy(data, offset);\n      offset += alignSize(part.value.length);\n    }\n  });\n  return '0x' + data.toString('hex');\n} // decode bytecode data from output names and types\n\n\nfunction decodeParams(names, types, data) {\n  var useNumberedParams = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true; // Names is optional, so shift over all the parameters if not provided\n\n  if (arguments.length < 3) {\n    data = types;\n    types = names;\n    names = [];\n  }\n\n  data = utils.hexOrBuffer(data);\n  var values = new Result();\n  var offset = 0;\n  types.forEach(function (type, index) {\n    var coder = getParamCoder(type);\n\n    if (coder.dynamic) {\n      var dynamicOffset = uint256Coder.decode(data, offset);\n      var result = coder.decode(data, dynamicOffset.value.toNumber());\n      offset += dynamicOffset.consumed;\n    } else {\n      var result = coder.decode(data, offset);\n      offset += result.consumed;\n    }\n\n    if (useNumberedParams) values[index] = result.value;\n\n    if (names[index]) {\n      values[names[index]] = result.value;\n    }\n  });\n  return values;\n} // encode method ABI object with values in an array, output bytecode\n\n\nfunction encodeMethod(method, values) {\n  var signature = method.name + '(' + utils.getKeys(method.inputs, 'type').join(',') + ')';\n  var signatureEncoded = '0x' + new Buffer(utils.keccak256(signature), 'hex').slice(0, 4).toString('hex');\n  var paramsEncoded = encodeParams(utils.getKeys(method.inputs, 'type'), values).substring(2);\n  return '' + signatureEncoded + paramsEncoded;\n} // decode method data bytecode, from method ABI object\n\n\nfunction decodeMethod(method, data) {\n  var outputNames = utils.getKeys(method.outputs, 'name', true);\n  var outputTypes = utils.getKeys(method.outputs, 'type');\n  return decodeParams(outputNames, outputTypes, utils.hexOrBuffer(data));\n} // decode method data bytecode, from method ABI object\n\n\nfunction encodeEvent(eventObject, values) {\n  return encodeMethod(eventObject, values);\n}\n\nfunction eventSignature(eventObject) {\n  var signature = eventObject.name + '(' + utils.getKeys(eventObject.inputs, 'type').join(',') + ')';\n  return '0x' + utils.keccak256(signature);\n} // decode method data bytecode, from method ABI object\n\n\nfunction decodeEvent(eventObject, data, topics) {\n  var useNumberedParams = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n  var nonIndexed = eventObject.inputs.filter(function (input) {\n    return !input.indexed;\n  });\n  var nonIndexedNames = utils.getKeys(nonIndexed, 'name', true);\n  var nonIndexedTypes = utils.getKeys(nonIndexed, 'type');\n  var event = decodeParams(nonIndexedNames, nonIndexedTypes, utils.hexOrBuffer(data), useNumberedParams);\n  var topicOffset = eventObject.anonymous ? 0 : 1;\n  eventObject.inputs.filter(function (input) {\n    return input.indexed;\n  }).map(function (input, i) {\n    var topic = new Buffer(topics[i + topicOffset].slice(2), 'hex');\n    var coder = getParamCoder(input.type);\n    event[input.name] = coder.decode(topic, 0).value;\n  });\n  event._eventName = eventObject.name;\n  return event;\n} // Decode a specific log item with a specific event abi\n\n\nfunction decodeLogItem(eventObject, log) {\n  var useNumberedParams = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n\n  if (eventObject && log.topics[0] === eventSignature(eventObject)) {\n    return decodeEvent(eventObject, log.data, log.topics, useNumberedParams);\n  }\n} // Create a decoder for all events defined in an abi. It returns a function which is called\n// on an array of log entries such as received from getLogs or getTransactionReceipt and parses\n// any matching log entries\n\n\nfunction logDecoder(abi) {\n  var useNumberedParams = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  var eventMap = {};\n  abi.filter(function (item) {\n    return item.type === 'event';\n  }).map(function (item) {\n    eventMap[eventSignature(item)] = item;\n  });\n  return function (logItems) {\n    return logItems.map(function (log) {\n      return decodeLogItem(eventMap[log.topics[0]], log, useNumberedParams);\n    }).filter(function (i) {\n      return i;\n    });\n  };\n}\n\nmodule.exports = {\n  encodeParams: encodeParams,\n  decodeParams: decodeParams,\n  encodeMethod: encodeMethod,\n  decodeMethod: decodeMethod,\n  encodeEvent: encodeEvent,\n  decodeEvent: decodeEvent,\n  decodeLogItem: decodeLogItem,\n  logDecoder: logDecoder,\n  eventSignature: eventSignature\n};","map":{"version":3,"sources":["F:/7color/node_modules/ethjs-abi/lib/index.js"],"names":["utils","require","uint256Coder","coderBoolean","coderFixedBytes","coderAddress","coderDynamicBytes","coderString","coderArray","paramTypePart","getParamCoder","Result","encodeParams","types","values","length","Error","parts","forEach","type","index","coder","push","dynamic","value","encode","alignSize","size","parseInt","Math","ceil","staticSize","dynamicSize","part","offset","dynamicOffset","data","Buffer","copy","toString","decodeParams","names","useNumberedParams","arguments","undefined","hexOrBuffer","decode","result","toNumber","consumed","encodeMethod","method","signature","name","getKeys","inputs","join","signatureEncoded","keccak256","slice","paramsEncoded","substring","decodeMethod","outputNames","outputs","outputTypes","encodeEvent","eventObject","eventSignature","decodeEvent","topics","nonIndexed","filter","input","indexed","nonIndexedNames","nonIndexedTypes","event","topicOffset","anonymous","map","i","topic","_eventName","decodeLogItem","log","logDecoder","abi","eventMap","item","logItems","module","exports"],"mappings":"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","sourcesContent":["'use strict';\r\n\r\n/* eslint-disable */\r\n\r\nvar utils = require('./utils/index.js');\r\nvar uint256Coder = utils.uint256Coder;\r\nvar coderBoolean = utils.coderBoolean;\r\nvar coderFixedBytes = utils.coderFixedBytes;\r\nvar coderAddress = utils.coderAddress;\r\nvar coderDynamicBytes = utils.coderDynamicBytes;\r\nvar coderString = utils.coderString;\r\nvar coderArray = utils.coderArray;\r\nvar paramTypePart = utils.paramTypePart;\r\nvar getParamCoder = utils.getParamCoder;\r\n\r\nfunction Result() {}\r\n\r\nfunction encodeParams(types, values) {\r\n  if (types.length !== values.length) {\r\n    throw new Error('[ethjs-abi] while encoding params, types/values mismatch, Your contract requires ' + types.length + ' types (arguments), and you passed in ' + values.length);\r\n  }\r\n\r\n  var parts = [];\r\n\r\n  types.forEach(function (type, index) {\r\n    var coder = getParamCoder(type);\r\n    parts.push({ dynamic: coder.dynamic, value: coder.encode(values[index]) });\r\n  });\r\n\r\n  function alignSize(size) {\r\n    return parseInt(32 * Math.ceil(size / 32));\r\n  }\r\n\r\n  var staticSize = 0,\r\n      dynamicSize = 0;\r\n  parts.forEach(function (part) {\r\n    if (part.dynamic) {\r\n      staticSize += 32;\r\n      dynamicSize += alignSize(part.value.length);\r\n    } else {\r\n      staticSize += alignSize(part.value.length);\r\n    }\r\n  });\r\n\r\n  var offset = 0,\r\n      dynamicOffset = staticSize;\r\n  var data = new Buffer(staticSize + dynamicSize);\r\n\r\n  parts.forEach(function (part, index) {\r\n    if (part.dynamic) {\r\n      uint256Coder.encode(dynamicOffset).copy(data, offset);\r\n      offset += 32;\r\n\r\n      part.value.copy(data, dynamicOffset);\r\n      dynamicOffset += alignSize(part.value.length);\r\n    } else {\r\n      part.value.copy(data, offset);\r\n      offset += alignSize(part.value.length);\r\n    }\r\n  });\r\n\r\n  return '0x' + data.toString('hex');\r\n}\r\n\r\n// decode bytecode data from output names and types\r\nfunction decodeParams(names, types, data) {\r\n  var useNumberedParams = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\r\n\r\n  // Names is optional, so shift over all the parameters if not provided\r\n  if (arguments.length < 3) {\r\n    data = types;\r\n    types = names;\r\n    names = [];\r\n  }\r\n\r\n  data = utils.hexOrBuffer(data);\r\n  var values = new Result();\r\n\r\n  var offset = 0;\r\n  types.forEach(function (type, index) {\r\n    var coder = getParamCoder(type);\r\n    if (coder.dynamic) {\r\n      var dynamicOffset = uint256Coder.decode(data, offset);\r\n      var result = coder.decode(data, dynamicOffset.value.toNumber());\r\n      offset += dynamicOffset.consumed;\r\n    } else {\r\n      var result = coder.decode(data, offset);\r\n      offset += result.consumed;\r\n    }\r\n    if (useNumberedParams) values[index] = result.value;\r\n    if (names[index]) {\r\n      values[names[index]] = result.value;\r\n    }\r\n  });\r\n  return values;\r\n}\r\n\r\n// encode method ABI object with values in an array, output bytecode\r\nfunction encodeMethod(method, values) {\r\n  var signature = method.name + '(' + utils.getKeys(method.inputs, 'type').join(',') + ')';\r\n  var signatureEncoded = '0x' + new Buffer(utils.keccak256(signature), 'hex').slice(0, 4).toString('hex');\r\n  var paramsEncoded = encodeParams(utils.getKeys(method.inputs, 'type'), values).substring(2);\r\n\r\n  return '' + signatureEncoded + paramsEncoded;\r\n}\r\n\r\n// decode method data bytecode, from method ABI object\r\nfunction decodeMethod(method, data) {\r\n  var outputNames = utils.getKeys(method.outputs, 'name', true);\r\n  var outputTypes = utils.getKeys(method.outputs, 'type');\r\n\r\n  return decodeParams(outputNames, outputTypes, utils.hexOrBuffer(data));\r\n}\r\n\r\n// decode method data bytecode, from method ABI object\r\nfunction encodeEvent(eventObject, values) {\r\n  return encodeMethod(eventObject, values);\r\n}\r\n\r\nfunction eventSignature(eventObject) {\r\n  var signature = eventObject.name + '(' + utils.getKeys(eventObject.inputs, 'type').join(',') + ')';\r\n  return '0x' + utils.keccak256(signature);\r\n}\r\n\r\n// decode method data bytecode, from method ABI object\r\nfunction decodeEvent(eventObject, data, topics) {\r\n  var useNumberedParams = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\r\n\r\n  var nonIndexed = eventObject.inputs.filter(function (input) {\r\n    return !input.indexed;\r\n  });\r\n  var nonIndexedNames = utils.getKeys(nonIndexed, 'name', true);\r\n  var nonIndexedTypes = utils.getKeys(nonIndexed, 'type');\r\n  var event = decodeParams(nonIndexedNames, nonIndexedTypes, utils.hexOrBuffer(data), useNumberedParams);\r\n  var topicOffset = eventObject.anonymous ? 0 : 1;\r\n  eventObject.inputs.filter(function (input) {\r\n    return input.indexed;\r\n  }).map(function (input, i) {\r\n    var topic = new Buffer(topics[i + topicOffset].slice(2), 'hex');\r\n    var coder = getParamCoder(input.type);\r\n    event[input.name] = coder.decode(topic, 0).value;\r\n  });\r\n  event._eventName = eventObject.name;\r\n  return event;\r\n}\r\n\r\n// Decode a specific log item with a specific event abi\r\nfunction decodeLogItem(eventObject, log) {\r\n  var useNumberedParams = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\r\n\r\n  if (eventObject && log.topics[0] === eventSignature(eventObject)) {\r\n    return decodeEvent(eventObject, log.data, log.topics, useNumberedParams);\r\n  }\r\n}\r\n\r\n// Create a decoder for all events defined in an abi. It returns a function which is called\r\n// on an array of log entries such as received from getLogs or getTransactionReceipt and parses\r\n// any matching log entries\r\nfunction logDecoder(abi) {\r\n  var useNumberedParams = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\r\n\r\n  var eventMap = {};\r\n  abi.filter(function (item) {\r\n    return item.type === 'event';\r\n  }).map(function (item) {\r\n    eventMap[eventSignature(item)] = item;\r\n  });\r\n  return function (logItems) {\r\n    return logItems.map(function (log) {\r\n      return decodeLogItem(eventMap[log.topics[0]], log, useNumberedParams);\r\n    }).filter(function (i) {\r\n      return i;\r\n    });\r\n  };\r\n}\r\n\r\nmodule.exports = {\r\n  encodeParams: encodeParams,\r\n  decodeParams: decodeParams,\r\n  encodeMethod: encodeMethod,\r\n  decodeMethod: decodeMethod,\r\n  encodeEvent: encodeEvent,\r\n  decodeEvent: decodeEvent,\r\n  decodeLogItem: decodeLogItem,\r\n  logDecoder: logDecoder,\r\n  eventSignature: eventSignature\r\n};"]},"metadata":{},"sourceType":"script"}