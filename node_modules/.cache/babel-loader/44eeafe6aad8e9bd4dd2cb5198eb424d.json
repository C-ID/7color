{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _constants = require(\"./constants\");\n\nvar _errorSerialization = require(\"./errorSerialization\");\n/**\r\n * Listens for \"call\" messages coming from the remote, executes the corresponding method, and\r\n * responds with the return value.\r\n * @param {Object} info Information about the local and remote windows.\r\n * @param {Object} methods The keys are the names of the methods that can be called by the remote\r\n * while the values are the method functions.\r\n * @param {Promise} destructionPromise A promise resolved when destroy() is called on the penpal\r\n * connection.\r\n * @returns {Function} A function that may be called to disconnect the receiver.\r\n */\n\n\nvar _default = (info, methods, log) => {\n  const localName = info.localName,\n        local = info.local,\n        remote = info.remote,\n        originForSending = info.originForSending,\n        originForReceiving = info.originForReceiving;\n  let destroyed = false;\n  log(`${localName}: Connecting call receiver`);\n\n  const handleMessageEvent = event => {\n    if (event.source !== remote || event.data.penpal !== _constants.CALL) {\n      return;\n    }\n\n    if (event.origin !== originForReceiving) {\n      log(`${localName} received message from origin ${event.origin} which did not match expected origin ${originForReceiving}`);\n      return;\n    }\n\n    const _event$data = event.data,\n          methodName = _event$data.methodName,\n          args = _event$data.args,\n          id = _event$data.id;\n    log(`${localName}: Received ${methodName}() call`);\n\n    const createPromiseHandler = resolution => {\n      return returnValue => {\n        log(`${localName}: Sending ${methodName}() reply`);\n\n        if (destroyed) {\n          // It's possible to throw an error here, but it would need to be thrown asynchronously\n          // and would only be catchable using window.onerror. This is because the consumer\n          // is merely returning a value from their method and not calling any function\n          // that they could wrap in a try-catch. Even if the consumer were to catch the error,\n          // the value of doing so is questionable. Instead, we'll just log a message.\n          log(`${localName}: Unable to send ${methodName}() reply due to destroyed connection`);\n          return;\n        }\n\n        const message = {\n          penpal: _constants.REPLY,\n          id,\n          resolution,\n          returnValue\n        };\n\n        if (resolution === _constants.REJECTED && returnValue instanceof Error) {\n          message.returnValue = (0, _errorSerialization.serializeError)(returnValue);\n          message.returnValueIsError = true;\n        }\n\n        try {\n          remote.postMessage(message, originForSending);\n        } catch (err) {\n          // If a consumer attempts to send an object that's not cloneable (e.g., window),\n          // we want to ensure the receiver's promise gets rejected.\n          if (err.name === _constants.DATA_CLONE_ERROR) {\n            remote.postMessage({\n              penpal: _constants.REPLY,\n              id,\n              resolution: _constants.REJECTED,\n              returnValue: (0, _errorSerialization.serializeError)(err),\n              returnValueIsError: true\n            }, originForSending);\n          }\n\n          throw err;\n        }\n      };\n    };\n\n    new Promise(resolve => resolve(methods[methodName].apply(methods, args))).then(createPromiseHandler(_constants.FULFILLED), createPromiseHandler(_constants.REJECTED));\n  };\n\n  local.addEventListener(_constants.MESSAGE, handleMessageEvent);\n  return () => {\n    destroyed = true;\n    local.removeEventListener(_constants.MESSAGE, handleMessageEvent);\n  };\n};\n\nexports.default = _default;\nmodule.exports = exports.default;","map":{"version":3,"sources":["F:/7color/node_modules/penpal/lib/connectCallReceiver.js"],"names":["Object","defineProperty","exports","value","default","_constants","require","_errorSerialization","_default","info","methods","log","localName","local","remote","originForSending","originForReceiving","destroyed","handleMessageEvent","event","source","data","penpal","CALL","origin","_event$data","methodName","args","id","createPromiseHandler","resolution","returnValue","message","REPLY","REJECTED","Error","serializeError","returnValueIsError","postMessage","err","name","DATA_CLONE_ERROR","Promise","resolve","apply","then","FULFILLED","addEventListener","MESSAGE","removeEventListener","module"],"mappings":"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","sourcesContent":["\"use strict\";\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.default = void 0;\r\n\r\nvar _constants = require(\"./constants\");\r\n\r\nvar _errorSerialization = require(\"./errorSerialization\");\r\n\r\n/**\r\n * Listens for \"call\" messages coming from the remote, executes the corresponding method, and\r\n * responds with the return value.\r\n * @param {Object} info Information about the local and remote windows.\r\n * @param {Object} methods The keys are the names of the methods that can be called by the remote\r\n * while the values are the method functions.\r\n * @param {Promise} destructionPromise A promise resolved when destroy() is called on the penpal\r\n * connection.\r\n * @returns {Function} A function that may be called to disconnect the receiver.\r\n */\r\nvar _default = (info, methods, log) => {\r\n  const localName = info.localName,\r\n        local = info.local,\r\n        remote = info.remote,\r\n        originForSending = info.originForSending,\r\n        originForReceiving = info.originForReceiving;\r\n  let destroyed = false;\r\n  log(`${localName}: Connecting call receiver`);\r\n\r\n  const handleMessageEvent = event => {\r\n    if (event.source !== remote || event.data.penpal !== _constants.CALL) {\r\n      return;\r\n    }\r\n\r\n    if (event.origin !== originForReceiving) {\r\n      log(`${localName} received message from origin ${event.origin} which did not match expected origin ${originForReceiving}`);\r\n      return;\r\n    }\r\n\r\n    const _event$data = event.data,\r\n          methodName = _event$data.methodName,\r\n          args = _event$data.args,\r\n          id = _event$data.id;\r\n    log(`${localName}: Received ${methodName}() call`);\r\n\r\n    const createPromiseHandler = resolution => {\r\n      return returnValue => {\r\n        log(`${localName}: Sending ${methodName}() reply`);\r\n\r\n        if (destroyed) {\r\n          // It's possible to throw an error here, but it would need to be thrown asynchronously\r\n          // and would only be catchable using window.onerror. This is because the consumer\r\n          // is merely returning a value from their method and not calling any function\r\n          // that they could wrap in a try-catch. Even if the consumer were to catch the error,\r\n          // the value of doing so is questionable. Instead, we'll just log a message.\r\n          log(`${localName}: Unable to send ${methodName}() reply due to destroyed connection`);\r\n          return;\r\n        }\r\n\r\n        const message = {\r\n          penpal: _constants.REPLY,\r\n          id,\r\n          resolution,\r\n          returnValue\r\n        };\r\n\r\n        if (resolution === _constants.REJECTED && returnValue instanceof Error) {\r\n          message.returnValue = (0, _errorSerialization.serializeError)(returnValue);\r\n          message.returnValueIsError = true;\r\n        }\r\n\r\n        try {\r\n          remote.postMessage(message, originForSending);\r\n        } catch (err) {\r\n          // If a consumer attempts to send an object that's not cloneable (e.g., window),\r\n          // we want to ensure the receiver's promise gets rejected.\r\n          if (err.name === _constants.DATA_CLONE_ERROR) {\r\n            remote.postMessage({\r\n              penpal: _constants.REPLY,\r\n              id,\r\n              resolution: _constants.REJECTED,\r\n              returnValue: (0, _errorSerialization.serializeError)(err),\r\n              returnValueIsError: true\r\n            }, originForSending);\r\n          }\r\n\r\n          throw err;\r\n        }\r\n      };\r\n    };\r\n\r\n    new Promise(resolve => resolve(methods[methodName].apply(methods, args))).then(createPromiseHandler(_constants.FULFILLED), createPromiseHandler(_constants.REJECTED));\r\n  };\r\n\r\n  local.addEventListener(_constants.MESSAGE, handleMessageEvent);\r\n  return () => {\r\n    destroyed = true;\r\n    local.removeEventListener(_constants.MESSAGE, handleMessageEvent);\r\n  };\r\n};\r\n\r\nexports.default = _default;\r\nmodule.exports = exports.default;"]},"metadata":{},"sourceType":"script"}