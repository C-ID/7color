{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar ethUtil = require(\"ethereumjs-util\");\n\nvar _ = require(\"lodash\");\n\nvar constants_1 = require(\"../utils/constants\");\n\nvar queue_1 = require(\"../utils/queue\");\n\nvar RawCalldata =\n/** @class */\nfunction () {\n  function RawCalldata(value, hasSelector) {\n    if (hasSelector === void 0) {\n      hasSelector = true;\n    } // Sanity check\n\n\n    if (typeof value === 'string' && !_.startsWith(value, '0x')) {\n      throw new Error(\"Expected raw calldata to start with '0x'\");\n    } // Construct initial values\n\n\n    this._value = ethUtil.toBuffer(value);\n    this._selector = '0x';\n    this._scopes = new queue_1.Queue();\n\n    this._scopes.pushBack(RawCalldata._INITIAL_OFFSET);\n\n    this._offset = RawCalldata._INITIAL_OFFSET; // If there's a selector then slice it\n\n    if (hasSelector) {\n      var selectorBuf = this._value.slice(constants_1.constants.HEX_SELECTOR_LENGTH_IN_BYTES);\n\n      this._value = this._value.slice(constants_1.constants.HEX_SELECTOR_LENGTH_IN_BYTES);\n      this._selector = ethUtil.bufferToHex(selectorBuf);\n    }\n  }\n\n  RawCalldata.prototype.popBytes = function (lengthInBytes) {\n    var popBegin = this._offset;\n    var popEnd = popBegin + lengthInBytes;\n\n    if (popEnd > this._value.byteLength) {\n      throw new Error(\"Tried to decode beyond the end of calldata\");\n    }\n\n    var value = this._value.slice(popBegin, popEnd);\n\n    this.setOffset(popEnd);\n    return value;\n  };\n\n  RawCalldata.prototype.popWord = function () {\n    var wordInBytes = 32;\n    return this.popBytes(wordInBytes);\n  };\n\n  RawCalldata.prototype.popWords = function (length) {\n    var wordInBytes = 32;\n    return this.popBytes(length * wordInBytes);\n  };\n\n  RawCalldata.prototype.readBytes = function (from, to) {\n    var value = this._value.slice(from, to);\n\n    return value;\n  };\n\n  RawCalldata.prototype.setOffset = function (offsetInBytes) {\n    this._offset = offsetInBytes;\n  };\n\n  RawCalldata.prototype.startScope = function () {\n    this._scopes.pushFront(this._offset);\n  };\n\n  RawCalldata.prototype.endScope = function () {\n    this._scopes.popFront();\n  };\n\n  RawCalldata.prototype.getOffset = function () {\n    return this._offset;\n  };\n\n  RawCalldata.prototype.toAbsoluteOffset = function (relativeOffset) {\n    var scopeOffset = this._scopes.peekFront();\n\n    if (scopeOffset === undefined) {\n      throw new Error(\"Tried to access undefined scope.\");\n    }\n\n    var absoluteOffset = relativeOffset + scopeOffset;\n    return absoluteOffset;\n  };\n\n  RawCalldata.prototype.getSelector = function () {\n    return this._selector;\n  };\n\n  RawCalldata.prototype.getSizeInBytes = function () {\n    var sizeInBytes = this._value.byteLength;\n    return sizeInBytes;\n  };\n\n  RawCalldata._INITIAL_OFFSET = 0;\n  return RawCalldata;\n}();\n\nexports.RawCalldata = RawCalldata;","map":{"version":3,"sources":["../../../../src/abi_encoder/calldata/raw_calldata.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar ethUtil = require(\"ethereumjs-util\");\r\nvar _ = require(\"lodash\");\r\nvar constants_1 = require(\"../utils/constants\");\r\nvar queue_1 = require(\"../utils/queue\");\r\nvar RawCalldata = /** @class */ (function () {\r\n    function RawCalldata(value, hasSelector) {\r\n        if (hasSelector === void 0) { hasSelector = true; }\r\n        // Sanity check\r\n        if (typeof value === 'string' && !_.startsWith(value, '0x')) {\r\n            throw new Error(\"Expected raw calldata to start with '0x'\");\r\n        }\r\n        // Construct initial values\r\n        this._value = ethUtil.toBuffer(value);\r\n        this._selector = '0x';\r\n        this._scopes = new queue_1.Queue();\r\n        this._scopes.pushBack(RawCalldata._INITIAL_OFFSET);\r\n        this._offset = RawCalldata._INITIAL_OFFSET;\r\n        // If there's a selector then slice it\r\n        if (hasSelector) {\r\n            var selectorBuf = this._value.slice(constants_1.constants.HEX_SELECTOR_LENGTH_IN_BYTES);\r\n            this._value = this._value.slice(constants_1.constants.HEX_SELECTOR_LENGTH_IN_BYTES);\r\n            this._selector = ethUtil.bufferToHex(selectorBuf);\r\n        }\r\n    }\r\n    RawCalldata.prototype.popBytes = function (lengthInBytes) {\r\n        var popBegin = this._offset;\r\n        var popEnd = popBegin + lengthInBytes;\r\n        if (popEnd > this._value.byteLength) {\r\n            throw new Error(\"Tried to decode beyond the end of calldata\");\r\n        }\r\n        var value = this._value.slice(popBegin, popEnd);\r\n        this.setOffset(popEnd);\r\n        return value;\r\n    };\r\n    RawCalldata.prototype.popWord = function () {\r\n        var wordInBytes = 32;\r\n        return this.popBytes(wordInBytes);\r\n    };\r\n    RawCalldata.prototype.popWords = function (length) {\r\n        var wordInBytes = 32;\r\n        return this.popBytes(length * wordInBytes);\r\n    };\r\n    RawCalldata.prototype.readBytes = function (from, to) {\r\n        var value = this._value.slice(from, to);\r\n        return value;\r\n    };\r\n    RawCalldata.prototype.setOffset = function (offsetInBytes) {\r\n        this._offset = offsetInBytes;\r\n    };\r\n    RawCalldata.prototype.startScope = function () {\r\n        this._scopes.pushFront(this._offset);\r\n    };\r\n    RawCalldata.prototype.endScope = function () {\r\n        this._scopes.popFront();\r\n    };\r\n    RawCalldata.prototype.getOffset = function () {\r\n        return this._offset;\r\n    };\r\n    RawCalldata.prototype.toAbsoluteOffset = function (relativeOffset) {\r\n        var scopeOffset = this._scopes.peekFront();\r\n        if (scopeOffset === undefined) {\r\n            throw new Error(\"Tried to access undefined scope.\");\r\n        }\r\n        var absoluteOffset = relativeOffset + scopeOffset;\r\n        return absoluteOffset;\r\n    };\r\n    RawCalldata.prototype.getSelector = function () {\r\n        return this._selector;\r\n    };\r\n    RawCalldata.prototype.getSizeInBytes = function () {\r\n        var sizeInBytes = this._value.byteLength;\r\n        return sizeInBytes;\r\n    };\r\n    RawCalldata._INITIAL_OFFSET = 0;\r\n    return RawCalldata;\r\n}());\r\nexports.RawCalldata = RawCalldata;\r\n//# sourceMappingURL=raw_calldata.js.map"]},"metadata":{},"sourceType":"script"}