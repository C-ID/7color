{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function () {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t;\n  return {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  };\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) try {\n      if (f = 1, y && (t = y[op[0] & 2 ? \"return\" : op[0] ? \"throw\" : \"next\"]) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [0, t.value];\n\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n\n        case 7:\n          op = _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n\n            _.ops.push(op);\n\n            break;\n          }\n\n          if (t[2]) _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n      }\n\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\n\nexports.__esModule = true;\n/** Class representing a semaphore\r\n * Semaphores are initialized with a number of permits that get aquired and released\r\n * over the lifecycle of the Semaphore. These permits limit the number of simultaneous\r\n * executions of the code that the Semaphore synchronizes. Functions can wait and stop\r\n * executing until a permit becomes available.\r\n *\r\n * Locks that only allow one execution of a critical section are a special case of\r\n * Semaphores. To construct a lock, initialize a Semaphore with a permit count of 1.\r\n *\r\n * This Semaphore class is implemented with the help of promises that get returned\r\n * by functions that wait for permits to become available. This makes it possible\r\n * to use async/await to synchronize your code.\r\n */\n\nvar Semaphore = function () {\n  /**\r\n   * Creates a semaphore.\r\n   * @param permits  The number of permits, i.e. things being allowed to run in parallel.\r\n   * To create a lock that only lets one thing run at a time, set this to 1.\r\n   * This number can also be negative.\r\n   */\n  function Semaphore(permits) {\n    this.promiseResolverQueue = [];\n    this.permits = permits;\n  }\n  /**\r\n   * Returns the number of available permits.\r\n   * @returns  The number of available permits.\r\n   */\n\n\n  Semaphore.prototype.getPermits = function () {\n    return this.permits;\n  };\n  /**\r\n   * Returns a promise used to wait for a permit to become available. This method should be awaited on.\r\n   * @returns  A promise that gets resolved when execution is allowed to proceed.\r\n   */\n\n\n  Semaphore.prototype.wait = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        if (this.permits > 0) {\n          this.permits -= 1;\n          return [2\n          /*return*/\n          , Promise.resolve(true)];\n        } // If there is no permit available, we return a promise that resolves once the semaphore gets\n        // signaled enough times that permits is equal to one.\n\n\n        return [2\n        /*return*/\n        , new Promise(function (resolver) {\n          return _this.promiseResolverQueue.push(resolver);\n        })];\n      });\n    });\n  };\n  /**\r\n   * Alias for {@linkcode Semaphore.wait}.\r\n   * @returns  A promise that gets resolved when execution is allowed to proceed.\r\n   */\n\n\n  Semaphore.prototype.acquire = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2\n        /*return*/\n        , this.wait()];\n      });\n    });\n  };\n  /**\r\n   * Same as {@linkcode Semaphore.wait} except the promise returned gets resolved with false if no\r\n   * permit becomes available in time.\r\n   * @param milliseconds  The time spent waiting before the wait is aborted. This is a lower bound,\r\n   * don't rely on it being precise.\r\n   * @returns  A promise that gets resolved with true when execution is allowed to proceed or\r\n   * false if the time given elapses before a permit becomes available.\r\n   */\n\n\n  Semaphore.prototype.waitFor = function (milliseconds) {\n    return __awaiter(this, void 0, void 0, function () {\n      var _this = this;\n\n      var resolver, promise;\n      return __generator(this, function (_a) {\n        if (this.permits > 0) {\n          this.permits -= 1;\n          return [2\n          /*return*/\n          , Promise.resolve(true)];\n        }\n\n        resolver = function (b) {\n          return void 0;\n        };\n\n        promise = new Promise(function (r) {\n          resolver = r;\n        }); // The saved resolver gets added to our list of promise resolvers so that it gets a chance\n        // to be resolved as a result of a call to signal().\n\n        this.promiseResolverQueue.push(resolver);\n        setTimeout(function () {\n          // We have to remove the promise resolver from our list. Resolving it twice would not be\n          // an issue but signal() always takes the next resolver from the queue and resolves it which\n          // would swallow a permit if we didn't remove it.\n          var index = _this.promiseResolverQueue.indexOf(resolver);\n\n          if (index !== -1) {\n            _this.promiseResolverQueue.splice(index, 1);\n          } else {// This is weird... TODO Think about what the best course of action would be at this point.\n            // Probably do nothing.\n          } // false because the wait was unsuccessful.\n\n\n          resolver(false);\n        }, milliseconds);\n        return [2\n        /*return*/\n        , promise];\n      });\n    });\n  };\n  /**\r\n   * Synchronous function that tries to acquire a permit and returns true if successful, false otherwise.\r\n   * @returns  Whether a permit could be acquired.\r\n   */\n\n\n  Semaphore.prototype.tryAcquire = function () {\n    if (this.permits > 0) {\n      this.permits -= 1;\n      return true;\n    }\n\n    return false;\n  };\n  /**\r\n   * Acquires all permits that are currently available and returns the number of acquired permits.\r\n   * @returns  Number of acquired permits.\r\n   */\n\n\n  Semaphore.prototype.drainPermits = function () {\n    if (this.permits > 0) {\n      var permitCount = this.permits;\n      this.permits = 0;\n      return permitCount;\n    }\n\n    return 0;\n  };\n  /**\r\n   * Increases the number of permits by one. If there are other functions waiting, one of them will\r\n   * continue to execute in a future iteration of the event loop.\r\n   */\n\n\n  Semaphore.prototype.signal = function () {\n    this.permits += 1;\n\n    if (this.permits > 1 && this.promiseResolverQueue.length > 0) {\n      throw new Error('this.permits should never be > 0 when there is someone waiting.');\n    } else if (this.permits === 1 && this.promiseResolverQueue.length > 0) {\n      // If there is someone else waiting, immediately consume the permit that was released\n      // at the beginning of this function and let the waiting function resume.\n      this.permits -= 1;\n      var nextResolver = this.promiseResolverQueue.shift();\n\n      if (nextResolver) {\n        nextResolver(true);\n      }\n    }\n  };\n  /**\r\n   * Alias for {@linkcode Semaphore.signal}.\r\n   */\n\n\n  Semaphore.prototype.release = function () {\n    this.signal();\n  };\n  /**\r\n   * Schedules func to be called once a permit becomes available.\r\n   * Returns a promise that resolves to the return value of func.\r\n   * @typeparam T  The return type of func.\r\n   * @param func  The function to be executed.\r\n   * @return  A promise that gets resolved with the return value of the function.\r\n   */\n\n\n  Semaphore.prototype.execute = function (func) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.wait()];\n\n          case 1:\n            _a.sent();\n\n            _a.label = 2;\n\n          case 2:\n            _a.trys.push([2,, 4, 5]);\n\n            return [4\n            /*yield*/\n            , func()];\n\n          case 3:\n            return [2\n            /*return*/\n            , _a.sent()];\n\n          case 4:\n            this.signal();\n            return [7\n            /*endfinally*/\n            ];\n\n          case 5:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  return Semaphore;\n}();\n\nexports[\"default\"] = Semaphore;","map":{"version":3,"sources":["F:/7color/node_modules/semaphore-async-await/dist/Semaphore.js"],"names":["__awaiter","thisArg","_arguments","P","generator","Promise","resolve","reject","fulfilled","value","step","next","e","rejected","result","done","then","apply","__generator","body","_","label","sent","t","trys","ops","f","y","verb","n","v","op","TypeError","call","pop","length","push","exports","__esModule","Semaphore","permits","promiseResolverQueue","prototype","getPermits","wait","_this","_a","resolver","acquire","waitFor","milliseconds","promise","b","r","setTimeout","index","indexOf","splice","tryAcquire","drainPermits","permitCount","signal","Error","nextResolver","shift","release","execute","func"],"mappings":"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","sourcesContent":["\"use strict\";\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nvar __generator = (this && this.__generator) || function (thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t;\r\n    return { next: verb(0), \"throw\": verb(1), \"return\": verb(2) };\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = y[op[0] & 2 ? \"return\" : op[0] ? \"throw\" : \"next\"]) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [0, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n};\r\nexports.__esModule = true;\r\n/** Class representing a semaphore\r\n * Semaphores are initialized with a number of permits that get aquired and released\r\n * over the lifecycle of the Semaphore. These permits limit the number of simultaneous\r\n * executions of the code that the Semaphore synchronizes. Functions can wait and stop\r\n * executing until a permit becomes available.\r\n *\r\n * Locks that only allow one execution of a critical section are a special case of\r\n * Semaphores. To construct a lock, initialize a Semaphore with a permit count of 1.\r\n *\r\n * This Semaphore class is implemented with the help of promises that get returned\r\n * by functions that wait for permits to become available. This makes it possible\r\n * to use async/await to synchronize your code.\r\n */\r\nvar Semaphore = (function () {\r\n    /**\r\n     * Creates a semaphore.\r\n     * @param permits  The number of permits, i.e. things being allowed to run in parallel.\r\n     * To create a lock that only lets one thing run at a time, set this to 1.\r\n     * This number can also be negative.\r\n     */\r\n    function Semaphore(permits) {\r\n        this.promiseResolverQueue = [];\r\n        this.permits = permits;\r\n    }\r\n    /**\r\n     * Returns the number of available permits.\r\n     * @returns  The number of available permits.\r\n     */\r\n    Semaphore.prototype.getPermits = function () {\r\n        return this.permits;\r\n    };\r\n    /**\r\n     * Returns a promise used to wait for a permit to become available. This method should be awaited on.\r\n     * @returns  A promise that gets resolved when execution is allowed to proceed.\r\n     */\r\n    Semaphore.prototype.wait = function () {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var _this = this;\r\n            return __generator(this, function (_a) {\r\n                if (this.permits > 0) {\r\n                    this.permits -= 1;\r\n                    return [2 /*return*/, Promise.resolve(true)];\r\n                }\r\n                // If there is no permit available, we return a promise that resolves once the semaphore gets\r\n                // signaled enough times that permits is equal to one.\r\n                return [2 /*return*/, new Promise(function (resolver) { return _this.promiseResolverQueue.push(resolver); })];\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Alias for {@linkcode Semaphore.wait}.\r\n     * @returns  A promise that gets resolved when execution is allowed to proceed.\r\n     */\r\n    Semaphore.prototype.acquire = function () {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            return __generator(this, function (_a) {\r\n                return [2 /*return*/, this.wait()];\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Same as {@linkcode Semaphore.wait} except the promise returned gets resolved with false if no\r\n     * permit becomes available in time.\r\n     * @param milliseconds  The time spent waiting before the wait is aborted. This is a lower bound,\r\n     * don't rely on it being precise.\r\n     * @returns  A promise that gets resolved with true when execution is allowed to proceed or\r\n     * false if the time given elapses before a permit becomes available.\r\n     */\r\n    Semaphore.prototype.waitFor = function (milliseconds) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var _this = this;\r\n            var resolver, promise;\r\n            return __generator(this, function (_a) {\r\n                if (this.permits > 0) {\r\n                    this.permits -= 1;\r\n                    return [2 /*return*/, Promise.resolve(true)];\r\n                }\r\n                resolver = function (b) { return void (0); };\r\n                promise = new Promise(function (r) {\r\n                    resolver = r;\r\n                });\r\n                // The saved resolver gets added to our list of promise resolvers so that it gets a chance\r\n                // to be resolved as a result of a call to signal().\r\n                this.promiseResolverQueue.push(resolver);\r\n                setTimeout(function () {\r\n                    // We have to remove the promise resolver from our list. Resolving it twice would not be\r\n                    // an issue but signal() always takes the next resolver from the queue and resolves it which\r\n                    // would swallow a permit if we didn't remove it.\r\n                    var index = _this.promiseResolverQueue.indexOf(resolver);\r\n                    if (index !== -1) {\r\n                        _this.promiseResolverQueue.splice(index, 1);\r\n                    }\r\n                    else {\r\n                        // This is weird... TODO Think about what the best course of action would be at this point.\r\n                        // Probably do nothing.\r\n                    }\r\n                    // false because the wait was unsuccessful.\r\n                    resolver(false);\r\n                }, milliseconds);\r\n                return [2 /*return*/, promise];\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Synchronous function that tries to acquire a permit and returns true if successful, false otherwise.\r\n     * @returns  Whether a permit could be acquired.\r\n     */\r\n    Semaphore.prototype.tryAcquire = function () {\r\n        if (this.permits > 0) {\r\n            this.permits -= 1;\r\n            return true;\r\n        }\r\n        return false;\r\n    };\r\n    /**\r\n     * Acquires all permits that are currently available and returns the number of acquired permits.\r\n     * @returns  Number of acquired permits.\r\n     */\r\n    Semaphore.prototype.drainPermits = function () {\r\n        if (this.permits > 0) {\r\n            var permitCount = this.permits;\r\n            this.permits = 0;\r\n            return permitCount;\r\n        }\r\n        return 0;\r\n    };\r\n    /**\r\n     * Increases the number of permits by one. If there are other functions waiting, one of them will\r\n     * continue to execute in a future iteration of the event loop.\r\n     */\r\n    Semaphore.prototype.signal = function () {\r\n        this.permits += 1;\r\n        if (this.permits > 1 && this.promiseResolverQueue.length > 0) {\r\n            throw new Error('this.permits should never be > 0 when there is someone waiting.');\r\n        }\r\n        else if (this.permits === 1 && this.promiseResolverQueue.length > 0) {\r\n            // If there is someone else waiting, immediately consume the permit that was released\r\n            // at the beginning of this function and let the waiting function resume.\r\n            this.permits -= 1;\r\n            var nextResolver = this.promiseResolverQueue.shift();\r\n            if (nextResolver) {\r\n                nextResolver(true);\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Alias for {@linkcode Semaphore.signal}.\r\n     */\r\n    Semaphore.prototype.release = function () {\r\n        this.signal();\r\n    };\r\n    /**\r\n     * Schedules func to be called once a permit becomes available.\r\n     * Returns a promise that resolves to the return value of func.\r\n     * @typeparam T  The return type of func.\r\n     * @param func  The function to be executed.\r\n     * @return  A promise that gets resolved with the return value of the function.\r\n     */\r\n    Semaphore.prototype.execute = function (func) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0: return [4 /*yield*/, this.wait()];\r\n                    case 1:\r\n                        _a.sent();\r\n                        _a.label = 2;\r\n                    case 2:\r\n                        _a.trys.push([2, , 4, 5]);\r\n                        return [4 /*yield*/, func()];\r\n                    case 3: return [2 /*return*/, _a.sent()];\r\n                    case 4:\r\n                        this.signal();\r\n                        return [7 /*endfinally*/];\r\n                    case 5: return [2 /*return*/];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    return Semaphore;\r\n}());\r\nexports[\"default\"] = Semaphore;\r\n"]},"metadata":{},"sourceType":"script"}