{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar ethUtil = require(\"ethereumjs-util\");\n\nvar _ = require(\"lodash\");\n\nvar configured_bignumber_1 = require(\"../../configured_bignumber\");\n\nvar constants_1 = require(\"../utils/constants\");\n\nfunction sanityCheckBigNumberRange(value_, minValue, maxValue) {\n  var value = new configured_bignumber_1.BigNumber(value_, 10);\n\n  if (value.isGreaterThan(maxValue)) {\n    throw new Error(\"Tried to assign value of \" + value + \", which exceeds max value of \" + maxValue);\n  } else if (value.isLessThan(minValue)) {\n    throw new Error(\"Tried to assign value of \" + value + \", which exceeds min value of \" + minValue);\n  } else if (value.isNaN()) {\n    throw new Error(\"Tried to assign NaN value\");\n  }\n}\n\nfunction bigNumberToPaddedBuffer(value) {\n  var valueHex = \"0x\" + value.toString(constants_1.constants.HEX_BASE);\n  var valueBuf = ethUtil.toBuffer(valueHex);\n  var valueBufPadded = ethUtil.setLengthLeft(valueBuf, constants_1.constants.EVM_WORD_WIDTH_IN_BYTES);\n  return valueBufPadded;\n}\n/**\r\n * Takes a numeric value and returns its ABI-encoded value\r\n * @param value_    The value to encode.\r\n * @return ABI Encoded value\r\n */\n\n\nfunction encodeNumericValue(value_) {\n  var value = new configured_bignumber_1.BigNumber(value_, 10); // Case 1/2: value is non-negative\n\n  if (value.isGreaterThanOrEqualTo(0)) {\n    var encodedPositiveValue = bigNumberToPaddedBuffer(value);\n    return encodedPositiveValue;\n  } // Case 2/2: Value is negative\n  // Use two's-complement to encode the value\n  // Step 1/3: Convert negative value to positive binary string\n\n\n  var valueBin = value.times(-1).toString(constants_1.constants.BIN_BASE); // Step 2/3: Invert binary value\n\n  var invertedValueBin = '1'.repeat(constants_1.constants.EVM_WORD_WIDTH_IN_BITS - valueBin.length);\n\n  _.each(valueBin, function (bit) {\n    invertedValueBin += bit === '1' ? '0' : '1';\n  });\n\n  var invertedValue = new configured_bignumber_1.BigNumber(invertedValueBin, constants_1.constants.BIN_BASE); // Step 3/3: Add 1 to inverted value\n\n  var negativeValue = invertedValue.plus(1);\n  var encodedValue = bigNumberToPaddedBuffer(negativeValue);\n  return encodedValue;\n}\n\nexports.encodeNumericValue = encodeNumericValue;\n/**\r\n * Takes a numeric value and returns its ABI-encoded value.\r\n * Performs an additional sanity check, given the min/max allowed value.\r\n * @param value_    The value to encode.\r\n * @return ABI Encoded value\r\n */\n\nfunction safeEncodeNumericValue(value, minValue, maxValue) {\n  sanityCheckBigNumberRange(value, minValue, maxValue);\n  var encodedValue = encodeNumericValue(value);\n  return encodedValue;\n}\n\nexports.safeEncodeNumericValue = safeEncodeNumericValue;\n/**\r\n * Takes an ABI-encoded numeric value and returns its decoded value as a BigNumber.\r\n * @param encodedValue    The encoded numeric value.\r\n * @param minValue        The minimum possible decoded value.\r\n * @return ABI Decoded value\r\n */\n\nfunction decodeNumericValue(encodedValue, minValue) {\n  var valueHex = ethUtil.bufferToHex(encodedValue); // Case 1/3: value is definitely non-negative because of numeric boundaries\n\n  var value = new configured_bignumber_1.BigNumber(valueHex, constants_1.constants.HEX_BASE);\n\n  if (!minValue.isLessThan(0)) {\n    return value;\n  } // Case 2/3: value is non-negative because there is no leading 1 (encoded as two's-complement)\n\n\n  var valueBin = value.toString(constants_1.constants.BIN_BASE);\n\n  var isValueNegative = valueBin.length === constants_1.constants.EVM_WORD_WIDTH_IN_BITS && _.startsWith(valueBin[0], '1');\n\n  if (!isValueNegative) {\n    return value;\n  } // Case 3/3: value is negative\n  // Step 1/3: Invert b inary value\n\n\n  var invertedValueBin = '';\n\n  _.each(valueBin, function (bit) {\n    invertedValueBin += bit === '1' ? '0' : '1';\n  });\n\n  var invertedValue = new configured_bignumber_1.BigNumber(invertedValueBin, constants_1.constants.BIN_BASE); // Step 2/3: Add 1 to inverted value\n  // The result is the two's-complement representation of the input value.\n\n  var positiveValue = invertedValue.plus(1); // Step 3/3: Invert positive value to get the negative value\n\n  var negativeValue = positiveValue.times(-1);\n  return negativeValue;\n}\n\nexports.decodeNumericValue = decodeNumericValue;\n/**\r\n * Takes an ABI-encoded numeric value and returns its decoded value as a BigNumber.\r\n * Performs an additional sanity check, given the min/max allowed value.\r\n * @param encodedValue    The encoded numeric value.\r\n * @param minValue        The minimum possible decoded value.\r\n * @return ABI Decoded value\r\n */\n\nfunction safeDecodeNumericValue(encodedValue, minValue, maxValue) {\n  var value = decodeNumericValue(encodedValue, minValue);\n  sanityCheckBigNumberRange(value, minValue, maxValue);\n  return value;\n}\n\nexports.safeDecodeNumericValue = safeDecodeNumericValue;","map":{"version":3,"sources":["../../../../src/abi_encoder/utils/math.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar ethUtil = require(\"ethereumjs-util\");\r\nvar _ = require(\"lodash\");\r\nvar configured_bignumber_1 = require(\"../../configured_bignumber\");\r\nvar constants_1 = require(\"../utils/constants\");\r\nfunction sanityCheckBigNumberRange(value_, minValue, maxValue) {\r\n    var value = new configured_bignumber_1.BigNumber(value_, 10);\r\n    if (value.isGreaterThan(maxValue)) {\r\n        throw new Error(\"Tried to assign value of \" + value + \", which exceeds max value of \" + maxValue);\r\n    }\r\n    else if (value.isLessThan(minValue)) {\r\n        throw new Error(\"Tried to assign value of \" + value + \", which exceeds min value of \" + minValue);\r\n    }\r\n    else if (value.isNaN()) {\r\n        throw new Error(\"Tried to assign NaN value\");\r\n    }\r\n}\r\nfunction bigNumberToPaddedBuffer(value) {\r\n    var valueHex = \"0x\" + value.toString(constants_1.constants.HEX_BASE);\r\n    var valueBuf = ethUtil.toBuffer(valueHex);\r\n    var valueBufPadded = ethUtil.setLengthLeft(valueBuf, constants_1.constants.EVM_WORD_WIDTH_IN_BYTES);\r\n    return valueBufPadded;\r\n}\r\n/**\r\n * Takes a numeric value and returns its ABI-encoded value\r\n * @param value_    The value to encode.\r\n * @return ABI Encoded value\r\n */\r\nfunction encodeNumericValue(value_) {\r\n    var value = new configured_bignumber_1.BigNumber(value_, 10);\r\n    // Case 1/2: value is non-negative\r\n    if (value.isGreaterThanOrEqualTo(0)) {\r\n        var encodedPositiveValue = bigNumberToPaddedBuffer(value);\r\n        return encodedPositiveValue;\r\n    }\r\n    // Case 2/2: Value is negative\r\n    // Use two's-complement to encode the value\r\n    // Step 1/3: Convert negative value to positive binary string\r\n    var valueBin = value.times(-1).toString(constants_1.constants.BIN_BASE);\r\n    // Step 2/3: Invert binary value\r\n    var invertedValueBin = '1'.repeat(constants_1.constants.EVM_WORD_WIDTH_IN_BITS - valueBin.length);\r\n    _.each(valueBin, function (bit) {\r\n        invertedValueBin += bit === '1' ? '0' : '1';\r\n    });\r\n    var invertedValue = new configured_bignumber_1.BigNumber(invertedValueBin, constants_1.constants.BIN_BASE);\r\n    // Step 3/3: Add 1 to inverted value\r\n    var negativeValue = invertedValue.plus(1);\r\n    var encodedValue = bigNumberToPaddedBuffer(negativeValue);\r\n    return encodedValue;\r\n}\r\nexports.encodeNumericValue = encodeNumericValue;\r\n/**\r\n * Takes a numeric value and returns its ABI-encoded value.\r\n * Performs an additional sanity check, given the min/max allowed value.\r\n * @param value_    The value to encode.\r\n * @return ABI Encoded value\r\n */\r\nfunction safeEncodeNumericValue(value, minValue, maxValue) {\r\n    sanityCheckBigNumberRange(value, minValue, maxValue);\r\n    var encodedValue = encodeNumericValue(value);\r\n    return encodedValue;\r\n}\r\nexports.safeEncodeNumericValue = safeEncodeNumericValue;\r\n/**\r\n * Takes an ABI-encoded numeric value and returns its decoded value as a BigNumber.\r\n * @param encodedValue    The encoded numeric value.\r\n * @param minValue        The minimum possible decoded value.\r\n * @return ABI Decoded value\r\n */\r\nfunction decodeNumericValue(encodedValue, minValue) {\r\n    var valueHex = ethUtil.bufferToHex(encodedValue);\r\n    // Case 1/3: value is definitely non-negative because of numeric boundaries\r\n    var value = new configured_bignumber_1.BigNumber(valueHex, constants_1.constants.HEX_BASE);\r\n    if (!minValue.isLessThan(0)) {\r\n        return value;\r\n    }\r\n    // Case 2/3: value is non-negative because there is no leading 1 (encoded as two's-complement)\r\n    var valueBin = value.toString(constants_1.constants.BIN_BASE);\r\n    var isValueNegative = valueBin.length === constants_1.constants.EVM_WORD_WIDTH_IN_BITS && _.startsWith(valueBin[0], '1');\r\n    if (!isValueNegative) {\r\n        return value;\r\n    }\r\n    // Case 3/3: value is negative\r\n    // Step 1/3: Invert b inary value\r\n    var invertedValueBin = '';\r\n    _.each(valueBin, function (bit) {\r\n        invertedValueBin += bit === '1' ? '0' : '1';\r\n    });\r\n    var invertedValue = new configured_bignumber_1.BigNumber(invertedValueBin, constants_1.constants.BIN_BASE);\r\n    // Step 2/3: Add 1 to inverted value\r\n    // The result is the two's-complement representation of the input value.\r\n    var positiveValue = invertedValue.plus(1);\r\n    // Step 3/3: Invert positive value to get the negative value\r\n    var negativeValue = positiveValue.times(-1);\r\n    return negativeValue;\r\n}\r\nexports.decodeNumericValue = decodeNumericValue;\r\n/**\r\n * Takes an ABI-encoded numeric value and returns its decoded value as a BigNumber.\r\n * Performs an additional sanity check, given the min/max allowed value.\r\n * @param encodedValue    The encoded numeric value.\r\n * @param minValue        The minimum possible decoded value.\r\n * @return ABI Decoded value\r\n */\r\nfunction safeDecodeNumericValue(encodedValue, minValue, maxValue) {\r\n    var value = decodeNumericValue(encodedValue, minValue);\r\n    sanityCheckBigNumberRange(value, minValue, maxValue);\r\n    return value;\r\n}\r\nexports.safeDecodeNumericValue = safeDecodeNumericValue;\r\n//# sourceMappingURL=math.js.map"]},"metadata":{},"sourceType":"script"}