{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport http from \"http\";\nimport https from \"https\";\nimport { gunzipSync } from \"zlib\";\nimport { parse } from \"url\";\nimport { arrayify, concat } from \"@ethersproject/bytes\";\nimport { shallowCopy } from \"@ethersproject/properties\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nfunction getResponse(request) {\n  return new Promise((resolve, reject) => {\n    request.once(\"response\", resp => {\n      const response = {\n        statusCode: resp.statusCode,\n        statusMessage: resp.statusMessage,\n        headers: Object.keys(resp.headers).reduce((accum, name) => {\n          let value = resp.headers[name];\n\n          if (Array.isArray(value)) {\n            value = value.join(\", \");\n          }\n\n          accum[name] = value;\n          return accum;\n        }, {}),\n        body: null\n      }; //resp.setEncoding(\"utf8\");\n\n      resp.on(\"data\", chunk => {\n        if (response.body == null) {\n          response.body = new Uint8Array(0);\n        }\n\n        response.body = concat([response.body, chunk]);\n      });\n      resp.on(\"end\", () => {\n        if (response.headers[\"content-encoding\"] === \"gzip\") {\n          //const size = response.body.length;\n          response.body = arrayify(gunzipSync(response.body)); //console.log(\"Delta:\", response.body.length - size, Buffer.from(response.body).toString());\n        }\n\n        resolve(response);\n      });\n      resp.on(\"error\", error => {\n        /* istanbul ignore next */\n        error.response = response;\n        reject(error);\n      });\n    });\n    request.on(\"error\", error => {\n      reject(error);\n    });\n  });\n} // The URL.parse uses null instead of the empty string\n\n\nfunction nonnull(value) {\n  if (value == null) {\n    return \"\";\n  }\n\n  return value;\n}\n\nexport function getUrl(href, options) {\n  return __awaiter(this, void 0, void 0, function* () {\n    if (options == null) {\n      options = {};\n    } // @TODO: Once we drop support for node 8, we can pass the href\n    //        firectly into request and skip adding the components\n    //        to this request object\n\n\n    const url = parse(href);\n    const request = {\n      protocol: nonnull(url.protocol),\n      hostname: nonnull(url.hostname),\n      port: nonnull(url.port),\n      path: nonnull(url.pathname) + nonnull(url.search),\n      method: options.method || \"GET\",\n      headers: shallowCopy(options.headers || {})\n    };\n\n    if (options.allowGzip) {\n      request.headers[\"accept-encoding\"] = \"gzip\";\n    }\n\n    let req = null;\n\n    switch (nonnull(url.protocol)) {\n      case \"http:\":\n        req = http.request(request);\n        break;\n\n      case \"https:\":\n        req = https.request(request);\n        break;\n\n      default:\n        /* istanbul ignore next */\n        logger.throwError(`unsupported protocol ${url.protocol}`, Logger.errors.UNSUPPORTED_OPERATION, {\n          protocol: url.protocol,\n          operation: \"request\"\n        });\n    }\n\n    if (options.body) {\n      req.write(Buffer.from(options.body));\n    }\n\n    req.end();\n    const response = yield getResponse(req);\n    return response;\n  });\n}","map":{"version":3,"sources":["../src.ts/geturl.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nimport http from \"http\";\r\nimport https from \"https\";\r\nimport { gunzipSync } from \"zlib\";\r\nimport { parse } from \"url\";\r\nimport { arrayify, concat } from \"@ethersproject/bytes\";\r\nimport { shallowCopy } from \"@ethersproject/properties\";\r\nimport { Logger } from \"@ethersproject/logger\";\r\nimport { version } from \"./_version\";\r\nconst logger = new Logger(version);\r\nfunction getResponse(request) {\r\n    return new Promise((resolve, reject) => {\r\n        request.once(\"response\", (resp) => {\r\n            const response = {\r\n                statusCode: resp.statusCode,\r\n                statusMessage: resp.statusMessage,\r\n                headers: Object.keys(resp.headers).reduce((accum, name) => {\r\n                    let value = resp.headers[name];\r\n                    if (Array.isArray(value)) {\r\n                        value = value.join(\", \");\r\n                    }\r\n                    accum[name] = value;\r\n                    return accum;\r\n                }, {}),\r\n                body: null\r\n            };\r\n            //resp.setEncoding(\"utf8\");\r\n            resp.on(\"data\", (chunk) => {\r\n                if (response.body == null) {\r\n                    response.body = new Uint8Array(0);\r\n                }\r\n                response.body = concat([response.body, chunk]);\r\n            });\r\n            resp.on(\"end\", () => {\r\n                if (response.headers[\"content-encoding\"] === \"gzip\") {\r\n                    //const size = response.body.length;\r\n                    response.body = arrayify(gunzipSync(response.body));\r\n                    //console.log(\"Delta:\", response.body.length - size, Buffer.from(response.body).toString());\r\n                }\r\n                resolve(response);\r\n            });\r\n            resp.on(\"error\", (error) => {\r\n                /* istanbul ignore next */\r\n                error.response = response;\r\n                reject(error);\r\n            });\r\n        });\r\n        request.on(\"error\", (error) => { reject(error); });\r\n    });\r\n}\r\n// The URL.parse uses null instead of the empty string\r\nfunction nonnull(value) {\r\n    if (value == null) {\r\n        return \"\";\r\n    }\r\n    return value;\r\n}\r\nexport function getUrl(href, options) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n        if (options == null) {\r\n            options = {};\r\n        }\r\n        // @TODO: Once we drop support for node 8, we can pass the href\r\n        //        firectly into request and skip adding the components\r\n        //        to this request object\r\n        const url = parse(href);\r\n        const request = {\r\n            protocol: nonnull(url.protocol),\r\n            hostname: nonnull(url.hostname),\r\n            port: nonnull(url.port),\r\n            path: (nonnull(url.pathname) + nonnull(url.search)),\r\n            method: (options.method || \"GET\"),\r\n            headers: shallowCopy(options.headers || {}),\r\n        };\r\n        if (options.allowGzip) {\r\n            request.headers[\"accept-encoding\"] = \"gzip\";\r\n        }\r\n        let req = null;\r\n        switch (nonnull(url.protocol)) {\r\n            case \"http:\":\r\n                req = http.request(request);\r\n                break;\r\n            case \"https:\":\r\n                req = https.request(request);\r\n                break;\r\n            default:\r\n                /* istanbul ignore next */\r\n                logger.throwError(`unsupported protocol ${url.protocol}`, Logger.errors.UNSUPPORTED_OPERATION, {\r\n                    protocol: url.protocol,\r\n                    operation: \"request\"\r\n                });\r\n        }\r\n        if (options.body) {\r\n            req.write(Buffer.from(options.body));\r\n        }\r\n        req.end();\r\n        const response = yield getResponse(req);\r\n        return response;\r\n    });\r\n}\r\n//# sourceMappingURL=geturl.js.map"]},"metadata":{},"sourceType":"module"}