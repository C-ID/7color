{"ast":null,"code":"\"use strict\";\n\nimport net from \"net\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nimport { JsonRpcProvider } from \"./json-rpc-provider\";\nexport class IpcProvider extends JsonRpcProvider {\n  constructor(path, network) {\n    logger.checkNew(new.target, IpcProvider);\n\n    if (path == null) {\n      logger.throwError(\"missing path\", Logger.errors.MISSING_ARGUMENT, {\n        arg: \"path\"\n      });\n    }\n\n    super(\"ipc://\" + path, network);\n    defineReadOnly(this, \"path\", path);\n  } // @TODO: Create a connection to the IPC path and use filters instead of polling for block\n\n\n  send(method, params) {\n    // This method is very simple right now. We create a new socket\n    // connection each time, which may be slower, but the main\n    // advantage we are aiming for now is security. This simplifies\n    // multiplexing requests (since we do not need to multiplex).\n    let payload = JSON.stringify({\n      method: method,\n      params: params,\n      id: 42,\n      jsonrpc: \"2.0\"\n    });\n    return new Promise((resolve, reject) => {\n      let response = Buffer.alloc(0);\n      let stream = net.connect(this.path);\n      stream.on(\"data\", data => {\n        response = Buffer.concat([response, data]);\n      });\n      stream.on(\"end\", () => {\n        try {\n          resolve(JSON.parse(response.toString()).result); // @TODO: Better pull apart the error\n\n          stream.destroy();\n        } catch (error) {\n          reject(error);\n          stream.destroy();\n        }\n      });\n      stream.on(\"error\", error => {\n        reject(error);\n        stream.destroy();\n      });\n      stream.write(payload);\n      stream.end();\n    });\n  }\n\n}","map":{"version":3,"sources":["../src.ts/ipc-provider.ts"],"names":[],"mappings":"AAAA;;AAEA,OAAO,GAAP,MAAgB,KAAhB;AAEA,SAAS,cAAT,QAA+B,2BAA/B;AAGA,SAAS,MAAT,QAAuB,uBAAvB;AACA,SAAS,OAAT,QAAwB,YAAxB;AACA,MAAM,MAAM,GAAG,IAAI,MAAJ,CAAW,OAAX,CAAf;AAEA,SAAS,eAAT,QAAgC,qBAAhC;AAGA,OAAM,MAAO,WAAP,SAA2B,eAA3B,CAA0C;AAG5C,EAAA,WAAA,CAAY,IAAZ,EAA0B,OAA1B,EAA8C;AAC1C,IAAA,MAAM,CAAC,QAAP,CAAgB,GAAG,CAAC,MAApB,EAA4B,WAA5B;;AAEA,QAAI,IAAI,IAAI,IAAZ,EAAkB;AACd,MAAA,MAAM,CAAC,UAAP,CAAkB,cAAlB,EAAkC,MAAM,CAAC,MAAP,CAAc,gBAAhD,EAAkE;AAAE,QAAA,GAAG,EAAE;AAAP,OAAlE;AACH;;AAED,UAAM,WAAW,IAAjB,EAAuB,OAAvB;AAEA,IAAA,cAAc,CAAC,IAAD,EAAO,MAAP,EAAe,IAAf,CAAd;AACH,GAb2C,CAe5C;;;AAEA,EAAA,IAAI,CAAC,MAAD,EAAiB,MAAjB,EAAmC;AACnC;AACA;AACA;AACA;AAEA,QAAI,OAAO,GAAG,IAAI,CAAC,SAAL,CAAe;AACzB,MAAA,MAAM,EAAE,MADiB;AAEzB,MAAA,MAAM,EAAE,MAFiB;AAGzB,MAAA,EAAE,EAAE,EAHqB;AAIzB,MAAA,OAAO,EAAE;AAJgB,KAAf,CAAd;AAOA,WAAO,IAAI,OAAJ,CAAY,CAAC,OAAD,EAAU,MAAV,KAAoB;AACnC,UAAI,QAAQ,GAAG,MAAM,CAAC,KAAP,CAAa,CAAb,CAAf;AAEA,UAAI,MAAM,GAAG,GAAG,CAAC,OAAJ,CAAY,KAAK,IAAjB,CAAb;AAEA,MAAA,MAAM,CAAC,EAAP,CAAU,MAAV,EAAmB,IAAD,IAAS;AACvB,QAAA,QAAQ,GAAG,MAAM,CAAC,MAAP,CAAc,CAAE,QAAF,EAAY,IAAZ,CAAd,CAAX;AACH,OAFD;AAIA,MAAA,MAAM,CAAC,EAAP,CAAU,KAAV,EAAiB,MAAK;AAClB,YAAI;AACA,UAAA,OAAO,CAAC,IAAI,CAAC,KAAL,CAAW,QAAQ,CAAC,QAAT,EAAX,EAAgC,MAAjC,CAAP,CADA,CAEA;;AACA,UAAA,MAAM,CAAC,OAAP;AACH,SAJD,CAIE,OAAO,KAAP,EAAc;AACZ,UAAA,MAAM,CAAC,KAAD,CAAN;AACA,UAAA,MAAM,CAAC,OAAP;AACH;AACJ,OATD;AAWA,MAAA,MAAM,CAAC,EAAP,CAAU,OAAV,EAAoB,KAAD,IAAU;AACzB,QAAA,MAAM,CAAC,KAAD,CAAN;AACA,QAAA,MAAM,CAAC,OAAP;AACH,OAHD;AAKA,MAAA,MAAM,CAAC,KAAP,CAAa,OAAb;AACA,MAAA,MAAM,CAAC,GAAP;AACH,KA3BM,CAAP;AA4BH;;AA1D2C","sourceRoot":"","sourcesContent":["\"use strict\";\r\nimport net from \"net\";\r\nimport { defineReadOnly } from \"@ethersproject/properties\";\r\nimport { Logger } from \"@ethersproject/logger\";\r\nimport { version } from \"./_version\";\r\nconst logger = new Logger(version);\r\nimport { JsonRpcProvider } from \"./json-rpc-provider\";\r\nexport class IpcProvider extends JsonRpcProvider {\r\n    constructor(path, network) {\r\n        logger.checkNew(new.target, IpcProvider);\r\n        if (path == null) {\r\n            logger.throwError(\"missing path\", Logger.errors.MISSING_ARGUMENT, { arg: \"path\" });\r\n        }\r\n        super(\"ipc://\" + path, network);\r\n        defineReadOnly(this, \"path\", path);\r\n    }\r\n    // @TODO: Create a connection to the IPC path and use filters instead of polling for block\r\n    send(method, params) {\r\n        // This method is very simple right now. We create a new socket\r\n        // connection each time, which may be slower, but the main\r\n        // advantage we are aiming for now is security. This simplifies\r\n        // multiplexing requests (since we do not need to multiplex).\r\n        let payload = JSON.stringify({\r\n            method: method,\r\n            params: params,\r\n            id: 42,\r\n            jsonrpc: \"2.0\"\r\n        });\r\n        return new Promise((resolve, reject) => {\r\n            let response = Buffer.alloc(0);\r\n            let stream = net.connect(this.path);\r\n            stream.on(\"data\", (data) => {\r\n                response = Buffer.concat([response, data]);\r\n            });\r\n            stream.on(\"end\", () => {\r\n                try {\r\n                    resolve(JSON.parse(response.toString()).result);\r\n                    // @TODO: Better pull apart the error\r\n                    stream.destroy();\r\n                }\r\n                catch (error) {\r\n                    reject(error);\r\n                    stream.destroy();\r\n                }\r\n            });\r\n            stream.on(\"error\", (error) => {\r\n                reject(error);\r\n                stream.destroy();\r\n            });\r\n            stream.write(payload);\r\n            stream.end();\r\n        });\r\n    }\r\n}\r\n//# sourceMappingURL=ipc-provider.js.map"]},"metadata":{},"sourceType":"module"}