{"ast":null,"code":"'use strict';\n\nvar schema = require('ethjs-schema');\n\nvar util = require('ethjs-util');\n\nvar numberToBN = require('number-to-bn');\n\nvar stripHexPrefix = require('strip-hex-prefix');\n\nvar padToEven = util.padToEven;\nvar arrayContainsArray = util.arrayContainsArray;\nvar getBinarySize = util.getBinarySize;\n/**\n * Format quantity values, either encode to hex or decode to BigNumber\n * should intake null, stringNumber, number, BN\n *\n * @method formatQuantity\n * @param {String|BigNumber|Number} value quantity or tag to convert\n * @param {Boolean} encode to hex or decode to BigNumber\n * @returns {Optional} output to BigNumber or string\n * @throws error if value is a float\n */\n\nfunction formatQuantity(value, encode) {\n  if (['string', 'number', 'object'].indexOf(typeof value) === -1 || value === null) {\n    return value;\n  }\n\n  var numberValue = numberToBN(value);\n\n  if (numberToBN(value).isNeg()) {\n    throw new Error('[ethjs-format] while formatting quantity \\'' + numberValue.toString(10) + '\\', invalid negative number. Number must be positive or zero.');\n  }\n\n  return encode ? '0x' + numberValue.toString(16) : numberValue;\n}\n/**\n * Format quantity or tag, if tag bypass return, else format quantity\n * should intake null, stringNumber, number, BN, string tag\n *\n * @method formatQuantityOrTag\n * @param {String|BigNumber|Number} value quantity or tag to convert\n * @param {Boolean} encode encode the number to hex or decode to BigNumber\n * @returns {Object|String} output to BigNumber or string\n * @throws error if value is a float\n */\n\n\nfunction formatQuantityOrTag(value, encode) {\n  var output = value; // eslint-disable-line\n  // if the value is a tag, bypass\n\n  if (schema.tags.indexOf(value) === -1) {\n    output = formatQuantity(value, encode);\n  }\n\n  return output;\n}\n/**\n * FormatData under strict conditions hex prefix\n *\n * @method formatData\n * @param {String} value the bytes data to be formatted\n * @param {Number} byteLength the required byte length (usually 20 or 32)\n * @returns {String} output output formatted data\n * @throws error if minimum length isnt met\n */\n\n\nfunction formatData(value, byteLength) {\n  var output = value; // eslint-disable-line\n\n  var outputByteLength = 0; // eslint-disable-line\n  // prefix only under strict conditions, else bypass\n\n  if (typeof value === 'string') {\n    output = '0x' + padToEven(stripHexPrefix(value));\n    outputByteLength = getBinarySize(output);\n  } // format double padded zeros.\n\n\n  if (output === '0x00') {\n    output = '0x0';\n  } // throw if bytelength is not correct\n\n\n  if (typeof byteLength === 'number' && value !== null && output !== '0x' && output !== '0x0' // support empty values\n  && (!/^[0-9A-Fa-f]+$/.test(stripHexPrefix(output)) || outputByteLength !== 2 + byteLength * 2)) {\n    throw new Error('[ethjs-format] hex string \\'' + output + '\\' must be an alphanumeric ' + (2 + byteLength * 2) + ' utf8 byte hex (chars: a-fA-F) string, is ' + outputByteLength + ' bytes');\n  }\n\n  return output;\n}\n/**\n * Format object, even with random RPC caviets\n *\n * @method formatObject\n * @param {String|Array} formatter the unit to convert to, default ether\n * @param {Object} value the object value\n * @param {Boolean} encode encode to hex or decode to BigNumber\n * @returns {Object} output object\n * @throws error if value is a float\n */\n\n\nfunction formatObject(formatter, value, encode) {\n  var output = Object.assign({}, value); // eslint-disable-line\n\n  var formatObject = null; // eslint-disable-line\n  // if the object is a string flag, then retreive the object\n\n  if (typeof formatter === 'string') {\n    if (formatter === 'Boolean|EthSyncing') {\n      formatObject = Object.assign({}, schema.objects.EthSyncing);\n    } else if (formatter === 'DATA|Transaction') {\n      formatObject = Object.assign({}, schema.objects.Transaction);\n    } else {\n      formatObject = Object.assign({}, schema.objects[formatter]);\n    }\n  } // check if all required data keys are fulfilled\n\n\n  if (!arrayContainsArray(Object.keys(value), formatObject.__required)) {\n    // eslint-disable-line\n    throw new Error('[ethjs-format] object ' + JSON.stringify(value) + ' must contain properties: ' + formatObject.__required.join(', ')); // eslint-disable-line\n  } // assume formatObject is an object, go through keys and format each\n\n\n  Object.keys(formatObject).forEach(function (valueKey) {\n    if (valueKey !== '__required' && typeof value[valueKey] !== 'undefined') {\n      output[valueKey] = format(formatObject[valueKey], value[valueKey], encode);\n    }\n  });\n  return output;\n}\n/**\n * Format array\n *\n * @method formatArray\n * @param {String|Array} formatter the unit to convert to, default ether\n * @param {Object} value the value in question\n * @param {Boolean} encode encode to hex or decode to BigNumber\n * @param {Number} lengthRequirement the required minimum array length\n * @returns {Object} output object\n * @throws error if minimum length isnt met\n */\n\n\nfunction formatArray(formatter, value, encode, lengthRequirement) {\n  var output = value.slice(); // eslint-disable-line\n\n  var formatObject = formatter; // eslint-disable-line\n  // if the formatter is an array or data, then make format object an array data\n\n  if (formatter === 'Array|DATA') {\n    formatObject = ['D'];\n  } // if formatter is a FilterChange and acts like a BlockFilter\n  // or PendingTx change format object to tx hash array\n\n\n  if (formatter === 'FilterChange' && typeof value[0] === 'string') {\n    formatObject = ['D32'];\n  } // enforce minimum value length requirements\n\n\n  if (encode === true && typeof lengthRequirement === 'number' && value.length < lengthRequirement) {\n    throw new Error('array ' + JSON.stringify(value) + ' must contain at least ' + lengthRequirement + ' params, but only contains ' + value.length + '.'); // eslint-disable-line\n  } // make new array, avoid mutation\n\n\n  formatObject = formatObject.slice(); // assume formatObject is an object, go through keys and format each\n\n  value.forEach(function (valueKey, valueIndex) {\n    // use key zero as formatter for all values, unless otherwise specified\n    var formatObjectKey = 0; // eslint-disable-line\n    // if format array is exact, check each argument against formatter argument\n\n    if (formatObject.length > 1) {\n      formatObjectKey = valueIndex;\n    }\n\n    output[valueIndex] = format(formatObject[formatObjectKey], valueKey, encode);\n  });\n  return output;\n}\n/**\n * Format various kinds of data to RPC spec or into digestable JS objects\n *\n * @method format\n * @param {String|Array} formatter the data formatter\n * @param {String|Array|Object|Null|Number} value the data value input\n * @param {Boolean} encode encode to hex or decode to BigNumbers, Strings, Booleans, Null\n * @param {Number} lengthRequirement the minimum data length requirement\n * @throws error if minimum length isnt met\n */\n\n\nfunction format(formatter, value, encode, lengthRequirement) {\n  var output = value; // eslint-disable-line\n  // if formatter is quantity or quantity or tag\n\n  if (formatter === 'Q') {\n    output = formatQuantity(value, encode);\n  } else if (formatter === 'Q|T') {\n    output = formatQuantityOrTag(value, encode);\n  } else if (formatter === 'D') {\n    output = formatData(value); // dont format data flagged objects like compiler output\n  } else if (formatter === 'D20') {\n    output = formatData(value, 20); // dont format data flagged objects like compiler output\n  } else if (formatter === 'D32') {\n    output = formatData(value, 32); // dont format data flagged objects like compiler output\n  } else {\n    // if value is an object or array\n    if (typeof value === 'object' && value !== null && Array.isArray(value) === false) {\n      output = formatObject(formatter, value, encode);\n    } else if (Array.isArray(value)) {\n      output = formatArray(formatter, value, encode, lengthRequirement);\n    }\n  }\n\n  return output;\n}\n/**\n * Format RPC inputs generally to the node or TestRPC\n *\n * @method formatInputs\n * @param {Object} method the data formatter\n * @param {Array} inputs the data inputs\n * @returns {Array} output the formatted inputs array\n * @throws error if minimum length isnt met\n */\n\n\nfunction formatInputs(method, inputs) {\n  return format(schema.methods[method][0], inputs, true, schema.methods[method][2]);\n}\n/**\n * Format RPC outputs generally from the node or TestRPC\n *\n * @method formatOutputs\n * @param {Object} method the data formatter\n * @param {Array|String|Null|Boolean|Object} outputs the data inputs\n * @returns {Array|String|Null|Boolean|Object} output the formatted data\n */\n\n\nfunction formatOutputs(method, outputs) {\n  return format(schema.methods[method][1], outputs, false);\n} // export formatters\n\n\nmodule.exports = {\n  schema: schema,\n  formatQuantity: formatQuantity,\n  formatQuantityOrTag: formatQuantityOrTag,\n  formatObject: formatObject,\n  formatArray: formatArray,\n  format: format,\n  formatInputs: formatInputs,\n  formatOutputs: formatOutputs\n};","map":{"version":3,"sources":["D:/proj/7color/node_modules/ethjs-format/lib/index.js"],"names":["schema","require","util","numberToBN","stripHexPrefix","padToEven","arrayContainsArray","getBinarySize","formatQuantity","value","encode","indexOf","numberValue","isNeg","Error","toString","formatQuantityOrTag","output","tags","formatData","byteLength","outputByteLength","test","formatObject","formatter","Object","assign","objects","EthSyncing","Transaction","keys","__required","JSON","stringify","join","forEach","valueKey","format","formatArray","lengthRequirement","slice","length","valueIndex","formatObjectKey","Array","isArray","formatInputs","method","inputs","methods","formatOutputs","outputs","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nvar schema = require('ethjs-schema');\nvar util = require('ethjs-util');\nvar numberToBN = require('number-to-bn');\nvar stripHexPrefix = require('strip-hex-prefix');\nvar padToEven = util.padToEven;\nvar arrayContainsArray = util.arrayContainsArray;\nvar getBinarySize = util.getBinarySize;\n\n/**\n * Format quantity values, either encode to hex or decode to BigNumber\n * should intake null, stringNumber, number, BN\n *\n * @method formatQuantity\n * @param {String|BigNumber|Number} value quantity or tag to convert\n * @param {Boolean} encode to hex or decode to BigNumber\n * @returns {Optional} output to BigNumber or string\n * @throws error if value is a float\n */\nfunction formatQuantity(value, encode) {\n  if (['string', 'number', 'object'].indexOf(typeof value) === -1 || value === null) {\n    return value;\n  }\n\n  var numberValue = numberToBN(value);\n\n  if (numberToBN(value).isNeg()) {\n    throw new Error('[ethjs-format] while formatting quantity \\'' + numberValue.toString(10) + '\\', invalid negative number. Number must be positive or zero.');\n  }\n\n  return encode ? '0x' + numberValue.toString(16) : numberValue;\n}\n\n/**\n * Format quantity or tag, if tag bypass return, else format quantity\n * should intake null, stringNumber, number, BN, string tag\n *\n * @method formatQuantityOrTag\n * @param {String|BigNumber|Number} value quantity or tag to convert\n * @param {Boolean} encode encode the number to hex or decode to BigNumber\n * @returns {Object|String} output to BigNumber or string\n * @throws error if value is a float\n */\nfunction formatQuantityOrTag(value, encode) {\n  var output = value; // eslint-disable-line\n\n  // if the value is a tag, bypass\n  if (schema.tags.indexOf(value) === -1) {\n    output = formatQuantity(value, encode);\n  }\n\n  return output;\n}\n\n/**\n * FormatData under strict conditions hex prefix\n *\n * @method formatData\n * @param {String} value the bytes data to be formatted\n * @param {Number} byteLength the required byte length (usually 20 or 32)\n * @returns {String} output output formatted data\n * @throws error if minimum length isnt met\n */\nfunction formatData(value, byteLength) {\n  var output = value; // eslint-disable-line\n  var outputByteLength = 0; // eslint-disable-line\n\n  // prefix only under strict conditions, else bypass\n  if (typeof value === 'string') {\n    output = '0x' + padToEven(stripHexPrefix(value));\n    outputByteLength = getBinarySize(output);\n  }\n\n  // format double padded zeros.\n  if (output === '0x00') {\n    output = '0x0';\n  }\n\n  // throw if bytelength is not correct\n  if (typeof byteLength === 'number' && value !== null && output !== '0x' && output !== '0x0' // support empty values\n  && (!/^[0-9A-Fa-f]+$/.test(stripHexPrefix(output)) || outputByteLength !== 2 + byteLength * 2)) {\n    throw new Error('[ethjs-format] hex string \\'' + output + '\\' must be an alphanumeric ' + (2 + byteLength * 2) + ' utf8 byte hex (chars: a-fA-F) string, is ' + outputByteLength + ' bytes');\n  }\n\n  return output;\n}\n\n/**\n * Format object, even with random RPC caviets\n *\n * @method formatObject\n * @param {String|Array} formatter the unit to convert to, default ether\n * @param {Object} value the object value\n * @param {Boolean} encode encode to hex or decode to BigNumber\n * @returns {Object} output object\n * @throws error if value is a float\n */\nfunction formatObject(formatter, value, encode) {\n  var output = Object.assign({}, value); // eslint-disable-line\n  var formatObject = null; // eslint-disable-line\n\n  // if the object is a string flag, then retreive the object\n  if (typeof formatter === 'string') {\n    if (formatter === 'Boolean|EthSyncing') {\n      formatObject = Object.assign({}, schema.objects.EthSyncing);\n    } else if (formatter === 'DATA|Transaction') {\n      formatObject = Object.assign({}, schema.objects.Transaction);\n    } else {\n      formatObject = Object.assign({}, schema.objects[formatter]);\n    }\n  }\n\n  // check if all required data keys are fulfilled\n  if (!arrayContainsArray(Object.keys(value), formatObject.__required)) {\n    // eslint-disable-line\n    throw new Error('[ethjs-format] object ' + JSON.stringify(value) + ' must contain properties: ' + formatObject.__required.join(', ')); // eslint-disable-line\n  }\n\n  // assume formatObject is an object, go through keys and format each\n  Object.keys(formatObject).forEach(function (valueKey) {\n    if (valueKey !== '__required' && typeof value[valueKey] !== 'undefined') {\n      output[valueKey] = format(formatObject[valueKey], value[valueKey], encode);\n    }\n  });\n\n  return output;\n}\n\n/**\n * Format array\n *\n * @method formatArray\n * @param {String|Array} formatter the unit to convert to, default ether\n * @param {Object} value the value in question\n * @param {Boolean} encode encode to hex or decode to BigNumber\n * @param {Number} lengthRequirement the required minimum array length\n * @returns {Object} output object\n * @throws error if minimum length isnt met\n */\nfunction formatArray(formatter, value, encode, lengthRequirement) {\n  var output = value.slice(); // eslint-disable-line\n  var formatObject = formatter; // eslint-disable-line\n\n  // if the formatter is an array or data, then make format object an array data\n  if (formatter === 'Array|DATA') {\n    formatObject = ['D'];\n  }\n\n  // if formatter is a FilterChange and acts like a BlockFilter\n  // or PendingTx change format object to tx hash array\n  if (formatter === 'FilterChange' && typeof value[0] === 'string') {\n    formatObject = ['D32'];\n  }\n\n  // enforce minimum value length requirements\n  if (encode === true && typeof lengthRequirement === 'number' && value.length < lengthRequirement) {\n    throw new Error('array ' + JSON.stringify(value) + ' must contain at least ' + lengthRequirement + ' params, but only contains ' + value.length + '.'); // eslint-disable-line\n  }\n\n  // make new array, avoid mutation\n  formatObject = formatObject.slice();\n\n  // assume formatObject is an object, go through keys and format each\n  value.forEach(function (valueKey, valueIndex) {\n    // use key zero as formatter for all values, unless otherwise specified\n    var formatObjectKey = 0; // eslint-disable-line\n\n    // if format array is exact, check each argument against formatter argument\n    if (formatObject.length > 1) {\n      formatObjectKey = valueIndex;\n    }\n\n    output[valueIndex] = format(formatObject[formatObjectKey], valueKey, encode);\n  });\n\n  return output;\n}\n\n/**\n * Format various kinds of data to RPC spec or into digestable JS objects\n *\n * @method format\n * @param {String|Array} formatter the data formatter\n * @param {String|Array|Object|Null|Number} value the data value input\n * @param {Boolean} encode encode to hex or decode to BigNumbers, Strings, Booleans, Null\n * @param {Number} lengthRequirement the minimum data length requirement\n * @throws error if minimum length isnt met\n */\nfunction format(formatter, value, encode, lengthRequirement) {\n  var output = value; // eslint-disable-line\n\n  // if formatter is quantity or quantity or tag\n  if (formatter === 'Q') {\n    output = formatQuantity(value, encode);\n  } else if (formatter === 'Q|T') {\n    output = formatQuantityOrTag(value, encode);\n  } else if (formatter === 'D') {\n    output = formatData(value); // dont format data flagged objects like compiler output\n  } else if (formatter === 'D20') {\n    output = formatData(value, 20); // dont format data flagged objects like compiler output\n  } else if (formatter === 'D32') {\n    output = formatData(value, 32); // dont format data flagged objects like compiler output\n  } else {\n    // if value is an object or array\n    if (typeof value === 'object' && value !== null && Array.isArray(value) === false) {\n      output = formatObject(formatter, value, encode);\n    } else if (Array.isArray(value)) {\n      output = formatArray(formatter, value, encode, lengthRequirement);\n    }\n  }\n\n  return output;\n}\n\n/**\n * Format RPC inputs generally to the node or TestRPC\n *\n * @method formatInputs\n * @param {Object} method the data formatter\n * @param {Array} inputs the data inputs\n * @returns {Array} output the formatted inputs array\n * @throws error if minimum length isnt met\n */\nfunction formatInputs(method, inputs) {\n  return format(schema.methods[method][0], inputs, true, schema.methods[method][2]);\n}\n\n/**\n * Format RPC outputs generally from the node or TestRPC\n *\n * @method formatOutputs\n * @param {Object} method the data formatter\n * @param {Array|String|Null|Boolean|Object} outputs the data inputs\n * @returns {Array|String|Null|Boolean|Object} output the formatted data\n */\nfunction formatOutputs(method, outputs) {\n  return format(schema.methods[method][1], outputs, false);\n}\n\n// export formatters\nmodule.exports = {\n  schema: schema,\n  formatQuantity: formatQuantity,\n  formatQuantityOrTag: formatQuantityOrTag,\n  formatObject: formatObject,\n  formatArray: formatArray,\n  format: format,\n  formatInputs: formatInputs,\n  formatOutputs: formatOutputs\n};"]},"metadata":{},"sourceType":"script"}