{"ast":null,"code":"// External Deps\nconst Eth = require('ethjs-query');\n\nconst EthContract = require('ethjs-contract');\n\nconst namehash = require('eth-ens-namehash'); // ABIs\n\n\nconst registryAbi = require('./abis/registry.json');\n\nconst resolverAbi = require('./abis/resolver.json'); // Map network to known ENS registries\n\n\nconst networkMap = require('ethereum-ens-network-map');\n\nconst emptyHash = '0x0000000000000000000000000000000000000000000000000000000000000000';\nconst emptyAddr = '0x0000000000000000000000000000000000000000';\nconst NotFoundError = new Error('ENS name not defined.');\nconst BadCharacterError = new Error('Illegal Character for ENS.');\n\nclass Ens {\n  constructor(opts = {}) {\n    const {\n      provider,\n      network\n    } = opts;\n    let {\n      registryAddress\n    } = opts; // Validations\n\n    if (!provider) {\n      throw new Error('The EthJsENS Constructor requires a provider.');\n    } // Requires EITHER a network or a registryAddress\n\n\n    if (!network && !registryAddress) {\n      throw new Error('The EthJsENS Constructor requires a network or registry address.');\n    }\n\n    this.provider = provider;\n    this.eth = new Eth(this.provider);\n    this.contract = new EthContract(this.eth);\n    this.namehash = namehash; // Link to Registry\n\n    this.Registry = this.contract(registryAbi);\n\n    if (!registryAddress && network) {\n      registryAddress = networkMap[network];\n    }\n\n    this.registry = this.Registry.at(registryAddress); // Create Resolver class\n\n    this.Resolver = this.contract(resolverAbi);\n  }\n\n  lookup(name = '') {\n    return this.getNamehash(name).then(node => {\n      if (node === emptyHash) {\n        return Promise.reject(NotFoundError);\n      }\n\n      return this.resolveAddressForNode(node);\n    });\n  }\n\n  getNamehash(name) {\n    try {\n      return Promise.resolve(namehash(name));\n    } catch (e) {\n      return Promise.reject(BadCharacterError);\n    }\n  }\n\n  getOwner(name = '') {\n    return this.getNamehash(name).then(node => this.getOwnerForNode(node));\n  }\n\n  getOwnerForNode(node) {\n    if (node === emptyHash) {\n      return Promise.reject(NotFoundError);\n    }\n\n    return this.registry.owner(node).then(result => {\n      const ownerAddress = result[0];\n\n      if (ownerAddress === emptyAddr) {\n        throw NotFoundError;\n      }\n\n      return ownerAddress;\n    });\n  }\n\n  getResolver(name = '') {\n    return this.getNamehash(name).then(node => this.getResolverForNode(node));\n  }\n\n  getResolverAddress(name = '') {\n    return this.getNamehash(name).then(node => this.getResolverAddressForNode(node));\n  }\n\n  getResolverForNode(node) {\n    if (!node.startsWith('0x')) {\n      node = `0x${node}`;\n    }\n\n    return this.getResolverAddressForNode(node).then(resolverAddress => {\n      return this.Resolver.at(resolverAddress);\n    });\n  }\n\n  getResolverAddressForNode(node) {\n    return this.registry.resolver(node).then(result => {\n      const resolverAddress = result[0];\n\n      if (resolverAddress === emptyAddr) {\n        throw NotFoundError;\n      }\n\n      return resolverAddress;\n    });\n  }\n\n  resolveAddressForNode(node) {\n    return this.getResolverForNode(node).then(resolver => {\n      return resolver.addr(node);\n    }).then(result => result[0]);\n  }\n\n  reverse(address) {\n    if (!address) {\n      return Promise.reject(new Error('Must supply an address to reverse lookup.'));\n    }\n\n    if (address.startsWith('0x')) {\n      address = address.slice(2);\n    }\n\n    const name = `${address.toLowerCase()}.addr.reverse`;\n    const node = namehash(name);\n    return this.getNamehash(name).then(node => this.getResolverForNode(node)).then(resolver => resolver.name(node)).then(results => results[0]);\n  }\n\n}\n\nmodule.exports = Ens;","map":{"version":3,"sources":["D:/proj/7color/node_modules/ethjs-ens/index.js"],"names":["Eth","require","EthContract","namehash","registryAbi","resolverAbi","networkMap","emptyHash","emptyAddr","NotFoundError","Error","BadCharacterError","Ens","constructor","opts","provider","network","registryAddress","eth","contract","Registry","registry","at","Resolver","lookup","name","getNamehash","then","node","Promise","reject","resolveAddressForNode","resolve","e","getOwner","getOwnerForNode","owner","result","ownerAddress","getResolver","getResolverForNode","getResolverAddress","getResolverAddressForNode","startsWith","resolverAddress","resolver","addr","reverse","address","slice","toLowerCase","results","module","exports"],"mappings":"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","sourcesContent":["// External Deps\nconst Eth = require('ethjs-query')\nconst EthContract = require('ethjs-contract')\nconst namehash = require('eth-ens-namehash')\n\n// ABIs\nconst registryAbi = require('./abis/registry.json')\nconst resolverAbi = require('./abis/resolver.json')\n\n// Map network to known ENS registries\nconst networkMap = require('ethereum-ens-network-map')\nconst emptyHash = '0x0000000000000000000000000000000000000000000000000000000000000000'\nconst emptyAddr = '0x0000000000000000000000000000000000000000'\n\nconst NotFoundError = new Error('ENS name not defined.')\nconst BadCharacterError = new Error('Illegal Character for ENS.')\n\nclass Ens {\n\n  constructor (opts = {}) {\n    const { provider, network } = opts\n    let { registryAddress } = opts\n\n    // Validations\n    if (!provider) {\n      throw new Error('The EthJsENS Constructor requires a provider.')\n    }\n\n    // Requires EITHER a network or a registryAddress\n    if (!network && !registryAddress) {\n      throw new Error('The EthJsENS Constructor requires a network or registry address.')\n    }\n\n    this.provider = provider\n    this.eth = new Eth(this.provider)\n    this.contract = new EthContract(this.eth)\n    this.namehash = namehash\n\n    // Link to Registry\n    this.Registry = this.contract(registryAbi)\n    if (!registryAddress && network) {\n      registryAddress = networkMap[network]\n    }\n    this.registry = this.Registry.at(registryAddress)\n\n    // Create Resolver class\n    this.Resolver = this.contract(resolverAbi)\n  }\n\n  lookup (name = '') {\n    return this.getNamehash(name)\n    .then((node) => {\n      if (node === emptyHash) {\n        return Promise.reject(NotFoundError)\n      }\n      return this.resolveAddressForNode(node)\n    })\n  }\n\n  getNamehash (name) {\n    try {\n      return Promise.resolve(namehash(name))\n    } catch (e) {\n      return Promise.reject(BadCharacterError)\n    }\n  }\n\n  getOwner (name = '') {\n    return this.getNamehash(name)\n    .then(node => this.getOwnerForNode(node))\n  }\n\n  getOwnerForNode (node) {\n    if (node === emptyHash) {\n      return Promise.reject(NotFoundError)\n    }\n    return this.registry.owner(node)\n    .then((result) => {\n      const ownerAddress = result[0]\n      if (ownerAddress === emptyAddr) {\n        throw NotFoundError\n      }\n\n      return ownerAddress\n    })\n  }\n\n  getResolver (name = '') {\n    return this.getNamehash(name)\n    .then(node => this.getResolverForNode(node))\n  }\n\n  getResolverAddress (name = '') {\n    return this.getNamehash(name)\n    .then(node => this.getResolverAddressForNode(node))\n  }\n\n  getResolverForNode (node) {\n    if (!node.startsWith('0x')) {\n      node = `0x${node}`\n    }\n\n    return this.getResolverAddressForNode(node)\n    .then((resolverAddress) => {\n      return this.Resolver.at(resolverAddress)\n    })\n  }\n\n  getResolverAddressForNode (node) {\n    return this.registry.resolver(node)\n    .then((result) => {\n      const resolverAddress = result[0]\n      if (resolverAddress === emptyAddr) {\n        throw NotFoundError\n      }\n      return resolverAddress\n    })\n  }\n\n  resolveAddressForNode (node) {\n    return this.getResolverForNode(node)\n    .then((resolver) => {\n      return resolver.addr(node)\n    })\n    .then(result => result[0])\n  }\n\n  reverse (address) {\n    if (!address) {\n      return Promise.reject(new Error('Must supply an address to reverse lookup.'))\n    }\n\n    if (address.startsWith('0x')) {\n      address = address.slice(2)\n    }\n\n    const name = `${address.toLowerCase()}.addr.reverse`\n    const node = namehash(name)\n    return this.getNamehash(name)\n    .then(node => this.getResolverForNode(node))\n    .then(resolver => resolver.name(node))\n    .then(results => results[0])\n  }\n\n}\n\nmodule.exports = Ens\n"]},"metadata":{},"sourceType":"script"}